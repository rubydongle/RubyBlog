---
title: arm64系统调用
categories:
  - 技术文章
date: 2019-12-06 13:43:11
tags:
---

## 用户空间
C库的用户空间实现bionic，在libc/arch_arm64/syscall中是arm64的系统调用实现
```bash
ruby@batman:~/aosp$ ls bionic/libc/arch-arm64/syscalls/
__accept4.S           __connect.S      ___fchmodat.S    ftruncate.S      getresgid.S          kill.S          mlock.S        pread64.S            recvfrom.S                sched_getscheduler.S     sethostname.S        setxattr.S           tee.S                 unlinkat.S
acct.S                delete_module.S  ___fchmod.S      __getcpu.S       getresuid.S          klogctl.S       mmap.S         preadv.S             recvmmsg.S                sched_rr_get_interval.S  setitimer.S          shutdown.S           tgkill.S              unshare.S
adjtimex.S            dup3.S           fchownat.S       __getcwd.S       getrlimit.S          lgetxattr.S     mount.S        prlimit64.S          recvmsg.S                 sched_setaffinity.S      setns.S              sigaltstack.S        __timer_create.S      utimensat.S
bind.S                dup.S            fchown.S         __getdents64.S   getrusage.S          linkat.S        mprotect.S     process_vm_readv.S   removexattr.S             sched_setparam.S         setpgid.S            __signalfd4.S        __timer_delete.S      vmsplice.S
__brk.S               epoll_create1.S  fcntl.S          getegid.S        getsid.S             listen.S        ___mremap.S    process_vm_writev.S  renameat.S                sched_setscheduler.S     setpriority.S        socketpair.S         timerfd_create.S      wait4.S
capget.S              epoll_ctl.S      fdatasync.S      geteuid.S        getsockname.S        listxattr.S     msync.S        __pselect6.S         __rt_sigaction.S          sched_yield.S            setregid.S           __socket.S           timerfd_gettime.S     __waitid.S
capset.S              __epoll_pwait.S  ___fgetxattr.S   getgid.S         getsockopt.S         llistxattr.S    munlockall.S   __ptrace.S           __rt_sigpending.S         sendfile.S               setresgid.S          splice.S             timerfd_settime.S     write.S
chdir.S               eventfd.S        ___flistxattr.S  getgroups.S      __gettimeofday.S     lremovexattr.S  munlock.S      pwrite64.S           __rt_sigprocmask.S        sendmmsg.S               setresuid.S          __statfs.S           __timer_getoverrun.S  writev.S
chroot.S              execve.S         flock.S          getitimer.S      getuid.S             lseek.S         munmap.S       pwritev.S            ___rt_sigqueueinfo.S      sendmsg.S                setreuid.S           swapoff.S            __timer_gettime.S
clock_adjtime.S       __exit.S         fremovexattr.S   getpeername.S    getxattr.S           lsetxattr.S     nanosleep.S    quotactl.S           __rt_sigsuspend.S         sendto.S                 setrlimit.S          swapon.S             __timer_settime.S
__clock_getres.S      _exit.S          ___fsetxattr.S   getpgid.S        init_module.S        madvise.S       __openat.S     readahead.S          __rt_sigtimedwait.S       setdomainname.S          setsid.S             symlinkat.S          times.S
__clock_gettime.S     ___faccessat.S   fstat64.S        __getpid.S       inotify_add_watch.S  mincore.S       personality.S  readlinkat.S         __sched_getaffinity.S     setfsgid.S               setsockopt.S         __sync_file_range.S  truncate.S
___clock_nanosleep.S  __fadvise64.S    fstatat64.S      getppid.S        inotify_init1.S      mkdirat.S       pipe2.S        read.S               sched_getparam.S          setfsuid.S               __set_tid_address.S  syncfs.S             umask.S
clock_settime.S       fallocate.S      __fstatfs.S      __getpriority.S  inotify_rm_watch.S   mknodat.S       __ppoll.S      readv.S              sched_get_priority_max.S  setgid.S                 settimeofday.S       sync.S               umount2.S
___close.S            fchdir.S         fsync.S          getrandom.S      __ioctl.S            mlockall.S      prctl.S        __reboot.S           sched_get_priority_min.S  setgroups.S              setuid.S             sysinfo.S            uname.S
```

系统调用kill的申明如下:
```c
int kill(pid_t pid, int sig);
```
用户侧实现如下:
```c
/* Generated by gensyscalls.py. Do not edit. */

#include <private/bionic_asm.h>

ENTRY(kill)
    mov     x8, __NR_kill
    svc     #0

    cmn     x0, #(MAX_ERRNO + 1)
    cneg    x0, x0, hi
    b.hi    __set_errno_internal

    ret
END(kill)
```

1.svc指令
> 参考:http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0203ic/Cacdfeci.html
SVC
超级用户调用。

语法
SVC{cond} #immed
其中：

cond
是一个可选的条件代码（请参阅条件执行）。

immed
是一个表达式，其取值为以下范围内的一个整数：

在 ARM 指令中为 0 到 224–1（24 位值）
在 16 位 Thumb 指令中为 0-255（8 位值）。

用法
SVC 指令会引发一个异常。 这意味着处理器模式会更改为超级用户模式，CPSR 会保存到超级用户模式 SPSR，并且执行会跳转到 SVC 向量（请参阅《开发指南》中的第 6 章 处理处理器异常）。处理器会忽略 immed。 但异常处理程序会获取它，借以确定所请求的服务。

Note
作为 ARM 汇编语言开发成果的一部分，SWI 指令已重命名为 SVC。 在此版本的 RVCT 中，SWI 指令反汇编为 SVC，并提供注释以指明这是以前的 SWI


2.cneg指令
CNEG
Conditional negate.
This instruction is an alias of CSNEG.

语法(Syntax)
CNEG  Wd, Wn, cond    ; 32-bit general registers
CNEG  Xd, Xn, cond    ; 64-bit general registers
其中(Where):
Wd
Is the 32-bit name of the general-purpose destination register, in the range 0 to 31.

Wn
Is the 32-bit name of the general-purpose source register in the range 0 to 31.

Xd
Is the 64-bit name of the general-purpose destination register, in the range 0 to 31.

Xn
Is the 64-bit name of the general-purpose source register in the range 0 to 31.

cond
Is one of the standard conditions, excluding AL and NV.

Show/hideSee also

3.csneg指令
CSNEG
Conditional select negation, returning the first input or negated second input.
This instruction is used by the alias CNEG.

Show/hideSyntax
CSNEG  Wd, Wn, Wm, cond    ; 32-bit general registers
CSNEG  Xd, Xn, Xm, cond    ; 64-bit general registers
Where:

Wd
Is the 32-bit name of the general-purpose destination register, in the range 0 to 31.

Wn
Is the 32-bit name of the first general-purpose source register, in the range 0 to 31.

Wm
Is the 32-bit name of the second general-purpose source register, in the range 0 to 31.

Xd
Is the 64-bit name of the general-purpose destination register, in the range 0 to 31.

Xn
Is the 64-bit name of the first general-purpose source register, in the range 0 to 31.

Xm
Is the 64-bit name of the second general-purpose source register, in the range 0 to 31.

cond
Is one of the standard conditions.


## 内核空间
1. arm64中断、系统调用入口
arch/arm64/kernel/entry.S
> 参考https://cloud.tencent.com/developer/article/1413292
> 参考https://blog.csdn.net/rikeyone/article/details/79919019
中断向量定义如下:
```c
/*
 * Exception vectors.
 */
        .pushsection ".entry.text", "ax"

        .align  11
ENTRY(vectors)
        kernel_ventry   1, sync_invalid                 // Synchronous EL1t
        kernel_ventry   1, irq_invalid                  // IRQ EL1t
        kernel_ventry   1, fiq_invalid                  // FIQ EL1t
        kernel_ventry   1, error_invalid                // Error EL1t

        kernel_ventry   1, sync                         // Synchronous EL1h
        kernel_ventry   1, irq                          // IRQ EL1h
        kernel_ventry   1, fiq_invalid                  // FIQ EL1h
        kernel_ventry   1, error_invalid                // Error EL1h

        kernel_ventry   0, sync                         // Synchronous 64-bit EL0
        kernel_ventry   0, irq                          // IRQ 64-bit EL0
        kernel_ventry   0, fiq_invalid                  // FIQ 64-bit EL0
        kernel_ventry   0, error_invalid                // Error 64-bit EL0

#ifdef CONFIG_COMPAT
        kernel_ventry   0, sync_compat, 32              // Synchronous 32-bit EL0
        kernel_ventry   0, irq_compat, 32               // IRQ 32-bit EL0
        kernel_ventry   0, fiq_invalid_compat, 32       // FIQ 32-bit EL0
        kernel_ventry   0, error_invalid_compat, 32     // Error 32-bit EL0
#else
        kernel_ventry   0, sync_invalid, 32             // Synchronous 32-bit EL0
        kernel_ventry   0, irq_invalid, 32              // IRQ 32-bit EL0
        kernel_ventry   0, fiq_invalid, 32              // FIQ 32-bit EL0
        kernel_ventry   0, error_invalid, 32            // Error 32-bit EL0
#endif
END(vectors)
```

kernel_ventry宏定义如下:
```c
        .macro kernel_ventry, el, label, regsize = 64
        .align 7
#ifdef CONFIG_UNMAP_KERNEL_AT_EL0
alternative_if ARM64_UNMAP_KERNEL_AT_EL0
        .if     \el == 0
        .if     \regsize == 64
        mrs     x30, tpidrro_el0
        msr     tpidrro_el0, xzr
        .else
        mov     x30, xzr
        .endif
        .endif
alternative_else_nop_endif
#endif

        sub     sp, sp, #S_FRAME_SIZE
        b       el\()\el\()_\label
        .endm
```
kernel_ventry 0, sync就是el0_sync

```c
#ifndef ENTRY
#define ENTRY(name) \
        .globl name ASM_NL \
        ALIGN ASM_NL \
        name:
#endif
#endif /* LINKER_SCRIPT */
```

异常可以分为4组，每组异常有4个，所以这里一共会设置16个entry。4组异常分别对应4种情况下发生异常时的处理。上面的4组，按照顺序分别对应如下4中情况：
> （1）运行级别不发生切换，从ELx变化到ELx，使用SP_EL0，这种情况在Linux kernel都是不处理的，使用invalid entry。
> （2）运行级别不发生切换，从ELx变化到ELx，使用SP_ELx。这种情况下在Linux中比较常见。
> （3）异常需要进行级别切换来进行处理，并且使用aarch64模式处理，比如64位用户态程序发生系统调用，CPU会从EL0切换到EL1，并且使用aarch64模式处理异常。
> （4）异常需要进行级别切换来进行处理，并且使用aarch32模式处理。比如32位用户态程序发生系统调用，CPU会从EL0切换到EL1，并且使用aarch32模式进行处理。

前面设置了异常向量表，我们来进一步查看SVC mode的处理。当系统调用时CPU会切换到SVC mode，并跳转到对应的地址去运行。
kernel中会配置两个SVC Handler，分别对应这SVC_32/SVC_64两种mode，32bit程序和64bit程序执行系统调用会跳转到两个不同的handler去执行。
内核在arch/arm64/kernel/entry.S汇编代码中设置了SVC异常entry。

2. 64-bit运行模式
如下函数设置了64-bit状态下的异常向量表设置，其中红色部分是svc handler配置：
```c
/*
 * EL0 mode handlers.
 */
        .align  6
el0_sync:
        kernel_entry 0
        mrs     x25, esr_el1                    // read the syndrome register
        lsr     x24, x25, #ESR_ELx_EC_SHIFT     // exception class
        cmp     x24, #ESR_ELx_EC_SVC64          // SVC in 64-bit state
        b.eq    el0_svc
        cmp     x24, #ESR_ELx_EC_DABT_LOW       // data abort in EL0
        b.eq    el0_da
        cmp     x24, #ESR_ELx_EC_IABT_LOW       // instruction abort in EL0
        b.eq    el0_ia
        cmp     x24, #ESR_ELx_EC_FP_ASIMD       // FP/ASIMD access
        b.eq    el0_fpsimd_acc
        cmp     x24, #ESR_ELx_EC_FP_EXC64       // FP/ASIMD exception
        b.eq    el0_fpsimd_exc
        cmp     x24, #ESR_ELx_EC_SYS64          // configurable trap
        b.eq    el0_sys
        cmp     x24, #ESR_ELx_EC_SP_ALIGN       // stack alignment exception
        b.eq    el0_sp_pc
        cmp     x24, #ESR_ELx_EC_PC_ALIGN       // pc alignment exception
        b.eq    el0_sp_pc
        cmp     x24, #ESR_ELx_EC_UNKNOWN        // unknown exception in EL0
        b.eq    el0_undef
        cmp     x24, #ESR_ELx_EC_BREAKPT_LOW    // debug exception in EL0
        b.ge    el0_dbg
        b       el0_inv
	......

ENDPROC(el0_sync)
```

el0_svc的实现如下：
```c
/*
 * SVC handler.
 */
    .align  6
el0_svc:
    adrp    stbl, sys_call_table        // load syscall table pointer
    uxtw    scno, w8            // syscall number in w8
    mov sc_nr, #__NR_syscalls
el0_svc_naked:                  // compat entry point
    stp x0, scno, [sp, #S_ORIG_X0]  // save the original x0 and syscall number
    enable_dbg_and_irq
    ct_user_exit 1
    ldr x16, [tsk, #TSK_TI_FLAGS]   // check for syscall hooks
    tst x16, #_TIF_SYSCALL_WORK
    b.ne    __sys_trace
    cmp     scno, sc_nr                     // check upper syscall limit
    b.hs    ni_sys
    ldr x16, [stbl, scno, lsl #3]   // address in the syscall table
    blr x16             // call sys_* routine
    b   ret_fast_syscall
ni_sys:
    mov x0, sp
    bl  do_ni_syscall
    b   ret_fast_syscall
ENDPROC(el0_svc)
```
可以看到它会去查找sys_call_table这个数组并找到对应的系统调用函数去执行，注意其中有一个关键函数do_ni_syscall，(no implement syscall),当系统调用遇到一些限制或者问题时会跳转到该函数去执行。
sys_call_table的定义在arch/arm64/kernel/sys.c
```c
/*
 * The sys_call_table array must be 4K aligned to be accessible from
 * kernel/entry.S.
 */
void * const sys_call_table[__NR_syscalls] __aligned(4096) = {
        [0 ... __NR_syscalls - 1] = sys_ni_syscall,
#include <asm/unistd.h>
};
```
这个数组在创建时首先会把所有的数组成员设置为sys_ni_syscall，而后根据asm/unistd.h中的内容做进一步初始化。其实最终该头文件会把include/uapi/asm-generic//unistd.h包含进来，也就是这个头文件会是最终定义数组的地方。
```c
/* fs/xattr.c */
#define __NR_setxattr 5
__SYSCALL(__NR_setxattr, sys_setxattr)
#define __NR_lsetxattr 6
__SYSCALL(__NR_lsetxattr, sys_lsetxattr)
#define __NR_fsetxattr 7
__SYSCALL(__NR_fsetxattr, sys_fsetxattr)
#define __NR_getxattr 8
__SYSCALL(__NR_getxattr, sys_getxattr)
#define __NR_lgetxattr 9
__SYSCALL(__NR_lgetxattr, sys_lgetxattr)
#define __NR_fgetxattr 10
__SYSCALL(__NR_fgetxattr, sys_fgetxattr)
#define __NR_listxattr 11
__SYSCALL(__NR_listxattr, sys_listxattr)
#define __NR_llistxattr 12
__SYSCALL(__NR_llistxattr, sys_llistxattr)
#define __NR_flistxattr 13
__SYSCALL(__NR_flistxattr, sys_flistxattr)
#define __NR_removexattr 14
__SYSCALL(__NR_removexattr, sys_removexattr)
#define __NR_lremovexattr 15
__SYSCALL(__NR_lremovexattr, sys_lremovexattr)
#define __NR_fremovexattr 16
__SYSCALL(__NR_fremovexattr, sys_fremovexattr)

/* fs/dcache.c */
#define __NR_getcwd 17
__SYSCALL(__NR_getcwd, sys_getcwd)

/* fs/cookies.c */
#define __NR_lookup_dcookie 18
__SC_COMP(__NR_lookup_dcookie, sys_lookup_dcookie, compat_sys_lookup_dcookie)

/* fs/eventfd.c */
#define __NR_eventfd2 19
__SYSCALL(__NR_eventfd2, sys_eventfd2)

/* fs/eventpoll.c */
#define __NR_epoll_create1 20
__SYSCALL(__NR_epoll_create1, sys_epoll_create1)
#define __NR_epoll_ctl 21
__SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)
#define __NR_epoll_pwait 22
__SC_COMP(__NR_epoll_pwait, sys_epoll_pwait, compat_sys_epoll_pwait)

/* fs/fcntl.c */
#define __NR_dup 23
__SYSCALL(__NR_dup, sys_dup)
#define __NR_dup3 24
__SYSCALL(__NR_dup3, sys_dup3)
```


## 异常向量表
> 参考:
> http://www.wowotech.net/armv8a_arch/238.html
> https://blog.csdn.net/shuaifengyun/article/details/79435755

1. EL1的异常向量表。
当发生一个异常，并且处理器迁移到了EL1这个exception level，那么该异常由EL1的异常向量表来决定如果跳转到相应的exception handler。
    1. EL1的异常向量表保存在VBAR_EL1寄存器中（Vector Base Address Register (EL1)），该寄存器的低11bit是reserve的，11～63表示了Vector Base Address，因此这里的异常向量表是2K对齐的。
    设置中断向量表的代码如下head.S中：
    ```c
    /*
 * The following fragment of code is executed with the MMU enabled.
 *
 *   x0 = __PHYS_OFFSET
 */
__primary_switched:
        adrp    x4, init_thread_union
        add     sp, x4, #THREAD_SIZE
        adr_l   x5, init_task
        msr     sp_el0, x5                      // Save thread_info

        adr_l   x8, vectors                     // load VBAR_EL1 with virtual
        msr     vbar_el1, x8                    // vector table address
        isb

    ```
    代码中将vectors中断向量表的地址存到寄存器x8中，然后存储到寄存器VBAR_EL1寄存器中.

    2. exception vector table中有很多entry（否则也不会叫做vector table了），发生了异常具体选择哪一个entry需要考虑下面的这些因素：该exception从何而来？（对于本场景，exception只能来自EL0或者EL1），使用哪一个stack pointer？（SP_EL0还是SP_EL1），哪一种类型的异常？（synchronous exception、IRQ、FIQ还是SError interrupt）。

    3. 异常向量表是分组的，每一组都包括四种类型的exception，分别对应synchronous exception（elx_sync or elx_sync_invalid），irq中断（elx_irq or elx_irq_invalid），fiq中断（elx_fiq or elx_fiq_invalid）以及SError中断（elx_error or elx_error_invalid）。这一组异常对应异常状态的迁移是EL1到EL1的迁移，并且选择使用了SP_EL0。对于linux kernel而言，这类exception vector实际上就是Invalid mode handlers。

    4. 如果用大家熟悉的语言，其实这一段exception vectors可以这样表述：这些是异常发生在内核态（EL1）并且系统配置为内核处理这些异常（这些异常导致PE迁移到EL1）时候的异常向量。目前版本的ARM64代码还没有fiq和SError这两种异常的支持。fiq在ARM ARM文档中建议是在secure state世界中处理，因此没有出现在linux中是合理的，但是为何SError为何不处理呢？估计是因为SError是一种异步异常，硬件没有提供足够的信息恢复，因此linux只能是按照invalid mode来处理。

    5. 异常发生在了用户态（EL0）并且该异常需要在内核态（EL1）中处理。

2. EL2的异常向量表
EL2是虚拟态,
EL2的异常向量表。在本文的场景下（不支持虚拟化），实际上EL2的异常向量表没有存在的意义，如果硬件支持EL2，这时候，linux kernel可以做为hypervisor存在。启动的时候，在el2_setup函数中会设定一个dummy的EL2异常向量表（__hyp_stub_vectors）。当然，真正的EL2的异常向量表会在kvm初始化的时候完成设定。


## 中断
在内核模式下
> arm gic v3 文档:https://static.docs.arm.com/ihi0069/c/IHI0069C_gic_architecture_specification.pdf
```c
/*
 * Interrupt handling.
 */
        .macro  irq_handler
        ldr_l   x1, handle_arch_irq
        mov     x0, sp
        irq_stack_entry
        blr     x1
        irq_stack_exit
        .endm

        .text

......

        .align  6
el1_irq:
        kernel_entry 1
        enable_dbg
#ifdef CONFIG_TRACE_IRQFLAGS
        bl      trace_hardirqs_off
#endif

        irq_handler

#ifdef CONFIG_PREEMPT
        ldr     w24, [tsk, #TSK_TI_PREEMPT]     // get preempt count
        cbnz    w24, 1f                         // preempt count != 0
        ldr     x0, [tsk, #TSK_TI_FLAGS]        // get flags
        tbz     x0, #TIF_NEED_RESCHED, 1f       // needs rescheduling?
        bl      el1_preempt
1:
#endif
#ifdef CONFIG_TRACE_IRQFLAGS
        bl      trace_hardirqs_on
#endif
        kernel_exit 1
ENDPROC(el1_irq)
```

跳转到handle_arch_irq执行
arch/arm/kernel/irq.c
```c
#ifdef CONFIG_MULTI_IRQ_HANDLER
void __init set_handle_irq(void (*handle_irq)(struct pt_regs *))
{
        if (handle_arch_irq)
                return;

        handle_arch_irq = handle_irq;
}
#endif
```
drivers/irqchip/irq-gic-v3.c

```c
static int __init gic_init_bases(void __iomem *dist_base,
                                 struct redist_region *rdist_regs,
                                 u32 nr_redist_regions,
                                 u64 redist_stride,
                                 struct fwnode_handle *handle)
{
        u32 typer;
        int gic_irqs;
        int err;

        if (!is_hyp_mode_available())
                static_key_slow_dec(&supports_deactivate);

        if (static_key_true(&supports_deactivate))
                pr_info("GIC: Using split EOI/Deactivate mode\n");

        gic_data.fwnode = handle;
        gic_data.dist_base = dist_base;
        gic_data.redist_regions = rdist_regs;
        gic_data.nr_redist_regions = nr_redist_regions;
        gic_data.redist_stride = redist_stride;

        /*
         * Find out how many interrupts are supported.
         * The GIC only supports up to 1020 interrupt sources (SGI+PPI+SPI)
         */
        typer = readl_relaxed(gic_data.dist_base + GICD_TYPER);
        gic_data.rdists.id_bits = GICD_TYPER_ID_BITS(typer);
        gic_irqs = GICD_TYPER_IRQS(typer);
        if (gic_irqs > 1020)
                gic_irqs = 1020;
        gic_data.irq_nr = gic_irqs;

        gic_data.domain = irq_domain_create_tree(handle, &gic_irq_domain_ops,
                                                 &gic_data);
        gic_data.rdists.rdist = alloc_percpu(typeof(*gic_data.rdists.rdist));

        if (WARN_ON(!gic_data.domain) || WARN_ON(!gic_data.rdists.rdist)) {
                err = -ENOMEM;
                goto out_free;
        }

        set_handle_irq(gic_handle_irq); // 设置irq handler

        if (IS_ENABLED(CONFIG_ARM_GIC_V3_ITS) && gic_dist_supports_lpis() &&
            !IS_ENABLED(CONFIG_ARM_GIC_V3_ACL))
                its_init(handle, &gic_data.rdists, gic_data.domain);

        gic_smp_init();
        gic_dist_init();
        gic_cpu_init();
        gic_cpu_pm_init();

        return 0;

out_free:
        if (gic_data.domain)
                irq_domain_remove(gic_data.domain);
        free_percpu(gic_data.rdists.rdist);
        return err;
}
```

## 参考
> 指令集：
> https://static.docs.arm.com/ddi0596/a/DDI_0596_ARM_a64_instruction_set_architecture.pdf
